<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>路由规则</title>
    <link href="/blog/2022/07/30/routing-rule/"/>
    <url>/blog/2022/07/30/routing-rule/</url>
    
    <content type="html"><![CDATA[<p>此任务将展示通过 Dubbo 中的路由规则做服务治理</p><p>路由规则在发起一次RPC调用前起到过滤目标服务器地址的作用，过滤后的地址列表，将作为消费端最终发起RPC调用的备选地址。</p><ul><li>条件路由。支持以服务或 Consumer 应用为粒度配置路由规则。</li><li>标签路由。以 Provider 应用为粒度配置路由规则。</li></ul><p>后续我们计划在 2.6.x 版本的基础上继续增强脚本路由功能。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><ul><li><p>安装idea</p></li><li><p>克隆<a href="https://github.com/apache/dubbo-samples.git">dubbo-samples</a>到本地，idea打开</p></li><li><p>运行dubbo-admin镜像并运行镜像</p></li></ul><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>dubbo-samples-governance示例包含dubbo-samples-configconditionrouter和dubbo-samples-tagrouter子示例，这2个子示例分别应用<strong>条件路由</strong>和<strong>标签路由</strong>的路由规则做服务治理。</p><p>此任务的最初目标是应用路由规则做服务治理。稍后，您将应用<strong>条件路由</strong>和<strong>标签路由</strong>的路由规则做服务治理。</p><h2 id="条件路由规则"><a href="#条件路由规则" class="headerlink" title="条件路由规则"></a>条件路由规则</h2><p>dubbo-samples-configconditionrouter示例中，BasicConsumer类和BascicProvider类为消费者类和提供者类，现在运行BasicProvider。成功后在Dubbo-Admin查询服务，可以看到应用governance-conditionroute-provider，如图所示：</p><p><img src="https://img.yilonghuang.com/BasicProvider1_check.png" alt="BasicProvider1_check"></p><p>现在再运行一个提供者示例，运行在20881端口，首先修改dubbo-demo-provider.xml，将&lt; dubbo:protocol &#x2F;&gt;标签中端口修改修改为20881，运行BasicProvider，验证提供者示例运行在20880端口和20881端口，点击详情，如图所示：</p><p><img src="https://img.yilonghuang.com/BasicProvider2_check.png" alt="BasicProvider2_check"></p><p>可以看到提供者示例分别运行在20880端口和20881端口。</p><p>现在完成环境搭建，开始条件路由的任务。</p><h3 id="任务1：对Consumer应用配置条件路由规则"><a href="#任务1：对Consumer应用配置条件路由规则" class="headerlink" title="任务1：对Consumer应用配置条件路由规则"></a>任务1：对Consumer应用配置条件路由规则</h3><p>在Dubbo-Admin点击服务治理&#x2F;条件路由，点击创建，规则如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs oxygene"># DemoService的sayHello方法只能消费所有端口为<span class="hljs-number">20880</span>的服务实例<br># DemoService2的sayHello方法只能消费所有端口为<span class="hljs-number">20881</span>的服务实例<br>---<br>scope: application<br>force: <span class="hljs-keyword">true</span><br>runtime: <span class="hljs-keyword">true</span><br>enabled: <span class="hljs-keyword">true</span><br>priority: <span class="hljs-number">2</span><br>key: governance-conditionrouter-consumer<br>conditions:<br>- <span class="hljs-keyword">interface</span>=org.apache.dubbo.samples.governance.api.DemoService&amp;<span class="hljs-keyword">method</span>=<span class="hljs-title function_">sayHello</span>=&gt;<span class="hljs-title function_">address</span>=*:<span class="hljs-number">20880</span><br>- <span class="hljs-keyword">interface</span>=org.apache.dubbo.samples.governance.api.DemoService2&amp;<span class="hljs-keyword">method</span>=<span class="hljs-title function_">sayHello</span>=&gt;<span class="hljs-title function_">address</span>=*:<span class="hljs-number">20881</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>如果创建路由规则失败，请先运行一个消费者示例，然后在创建路由规则</p></blockquote><p>运行BasicConsumer，DemoService的sayHello方法只能消费所有端口为20880的服务实例， DemoService2的sayHello方法只能消费所有端口为20881的服务实例，说明路由规则生效，运行结果截图：</p><p><img src="https://img.yilonghuang.com/condition-rule-result1.png" alt="condition-rule-result1"></p><h3 id="任务2：对服务配置条件路由规则"><a href="#任务2：对服务配置条件路由规则" class="headerlink" title="任务2：对服务配置条件路由规则"></a>任务2：对服务配置条件路由规则</h3><p>在Dubbo-Admin点击服务治理&#x2F;条件路由，点击创建，规则如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"># DemoService的sayHello方法只能消费所有端口为<span class="hljs-number">20880</span>的服务实例<br># DemoService的sayHi方法只能消费所有端口为<span class="hljs-number">20881</span>的服务实例<br>---<br>scope: service<br>force: <span class="hljs-keyword">true</span><br>runtime: <span class="hljs-keyword">true</span><br>enabled: <span class="hljs-keyword">true</span><br>key: org.apache.dubbo.samples.governance.api.DemoService<br>conditions:<br>  - <span class="hljs-keyword">method</span>=<span class="hljs-title function_">sayHello</span> =&gt; <span class="hljs-title function_">address</span>=*:<span class="hljs-number">20880</span><br>  - <span class="hljs-keyword">method</span>=<span class="hljs-title function_">sayHi</span> =&gt; <span class="hljs-title function_">address</span>=*:<span class="hljs-number">20881</span><br>...<br></code></pre></td></tr></table></figure><blockquote><p><strong>提示</strong></p><p>如果创建路由规则失败，请在DemoService创建sayHi方法，DemoServiceImpl创建sayHi方法实现，重新运行BasicProvider示例</p></blockquote><p>运行BasicConsumer，DemoService的sayHello方法只能消费所有端口为20880的服务实例， DemoService的sayHi方法只能消费所有端口为20881的服务实例，说明路由规则生效，运行结果截图：</p><p><img src="https://img.yilonghuang.com/condition-rule-result2.png" alt="condition-rule-result2"></p><h3 id="规则详解"><a href="#规则详解" class="headerlink" title="规则详解"></a>规则详解</h3><h4 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h4><ul><li><code>scope</code>表示路由规则的作用粒度，scope的取值会决定key的取值。<strong>必填</strong>。<ul><li>service 服务粒度</li><li>application 应用粒度</li></ul></li><li><code>Key</code>明确规则体作用在哪个服务或应用。<strong>必填</strong>。<ul><li>scope&#x3D;service时，key取值为[{group}:]{service}[:{version}]的组合</li><li>scope&#x3D;application时，key取值为application名称</li></ul></li><li><code>enabled=true</code> 当前路由规则是否生效，可不填，缺省生效。</li><li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 <code>false</code>。</li><li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 <code>true</code>，需要注意设置会影响调用的性能，可不填，缺省为 <code>false</code>。</li><li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 <code>0</code>。</li><li><code>conditions</code> 定义具体的路由规则内容。<strong>必填</strong>。</li></ul><h4 id="Conditions规则体"><a href="#Conditions规则体" class="headerlink" title="Conditions规则体"></a>Conditions规则体</h4><div class="code-wrapper"><pre><code class="hljs">`conditions`部分是规则的主体，由1到任意多条规则组成，下面我们就每个规则的配置语法做详细说明：</code></pre></div><ol><li><strong>格式</strong></li></ol><ul><li><code>=&gt;</code> 之前的为消费者匹配条件，所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</li><li><code>=&gt;</code> 之后为提供者地址列表的过滤条件，所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。</li><li>如果匹配条件为空，表示对所有消费方应用，如：<code>=&gt; host != 10.20.153.11</code></li><li>如果过滤条件为空，表示禁止访问，如：<code>host = 10.20.153.10 =&gt;</code></li></ul><ol start="2"><li><strong>表达式</strong></li></ol><p>参数支持：</p><ul><li>服务调用信息，如：method, argument 等，暂不支持参数路由</li><li>URL 本身的字段，如：protocol, host, port 等</li><li>以及 URL 上的所有参数，如：application, organization 等</li></ul><p>条件支持：</p><ul><li>等号 <code>=</code> 表示”匹配”，如：<code>host = 10.20.153.10</code></li><li>不等号 <code>!=</code> 表示”不匹配”，如：<code>host != 10.20.153.10</code></li></ul><p>值支持：</p><ul><li>以逗号 <code>,</code> 分隔多个值，如：<code>host != 10.20.153.10,10.20.153.11</code></li><li>以星号 <code>*</code> 结尾，表示通配，如：<code>host != 10.20.*</code></li><li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：<code>host = $host</code></li></ul><ol start="3"><li><strong>Condition示例</strong></li></ol><ul><li>排除预发布机：</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">=&gt; host != <span class="hljs-number">172.22</span>.<span class="hljs-number">3.91</span><br></code></pre></td></tr></table></figure><ul><li>白名单：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">register</span>.ip != <span class="hljs-number">10.20.153.10</span>,<span class="hljs-number">10.20.153.11</span> =&gt;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>一个服务只能有一条白名单规则，否则两条规则交叉，就都被筛选掉了</p></blockquote><ul><li>黑名单：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">register</span>.ip = <span class="hljs-number">10.20.153.10</span>,<span class="hljs-number">10.20.153.11</span> =&gt;<br></code></pre></td></tr></table></figure><ul><li>服务寄宿在应用上，只暴露一部分的机器，防止整个集群挂掉：</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">=&gt; host = <span class="hljs-number">172.22</span>.<span class="hljs-number">3.1</span>*,<span class="hljs-number">172.22</span>.<span class="hljs-number">3.2</span>*<br></code></pre></td></tr></table></figure><ul><li>为重要应用提供额外的机器：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">application</span> != kylin =&gt; host != <span class="hljs-number">172.22.3.95</span>,<span class="hljs-number">172.22.3.96</span><br></code></pre></td></tr></table></figure><ul><li>读写分离：</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">method</span> = <span class="hljs-title function_">find</span>*,<span class="hljs-title function_">list</span>*,<span class="hljs-title function_">get</span>*,<span class="hljs-title function_">is</span>* =&gt; <span class="hljs-title function_">host</span> = 172.22.3.94,172.22.3.95,172.22.3.96<br><span class="hljs-title function_">method</span> != <span class="hljs-title function_">find</span>*,<span class="hljs-title function_">list</span>*,<span class="hljs-title function_">get</span>*,<span class="hljs-title function_">is</span>* =&gt; <span class="hljs-title function_">host</span> = 172.22.3.97,172.22.3.98<br></code></pre></td></tr></table></figure><ul><li>前后台分离：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">application</span> = bops =&gt; host = <span class="hljs-number">172.22.3.91</span>,<span class="hljs-number">172.22.3.92</span>,<span class="hljs-number">172.22.3.93</span><br><span class="hljs-attribute">application</span> != bops =&gt; host = <span class="hljs-number">172.22.3.94</span>,<span class="hljs-number">172.22.3.95</span>,<span class="hljs-number">172.22.3.96</span><br></code></pre></td></tr></table></figure><ul><li>隔离不同机房网段：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">host</span> != <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.* =&gt; host != <span class="hljs-number">172</span>.<span class="hljs-number">22</span>.<span class="hljs-number">3</span>.*<br></code></pre></td></tr></table></figure><ul><li>提供者与消费者部署在同集群内，本机只访问本机的服务：</li></ul><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">=&gt; host = $host<br></code></pre></td></tr></table></figure><h2 id="标签路由规则"><a href="#标签路由规则" class="headerlink" title="标签路由规则"></a>标签路由规则</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p><p>dubbo-samples-tagrouter示例中，BasicConsumer类和BascicProvider类为消费者类和提供者类，现在运行BasicProvider。成功后在Dubbo-Admin查询服务，可以看到应用 governance-tagrouter-provider，如图所示：</p><p><img src="https://img.yilonghuang.com/BasicProvider3_check.png" alt="BasicProvider3_check"></p><p>现在再运行一个提供者示例，运行在20881端口，首先修改dubbo-demo-provider.xml，将&lt; dubbo:protocol &#x2F;&gt;标签中端口修改修改为20881，运行BasicProvider，验证提供者示例运行在20880端口和20881端口，点击详情，如图所示：</p><p><img src="https://img.yilonghuang.com/BasicProvider2_check.png" alt="BasicProvider2_check"></p><p>可以看到提供者示例分别运行在20880端口和20881端口。</p><p>现在完成环境搭建，开始标签路由的任务。</p><p>标签主要是指对Provider端应用实例的分组，目前有两种方式可以完成实例分组，分别是<code>动态规则打标</code>和<code>静态规则打标</code>，其中动态规则相较于静态规则优先级更高，而当两种规则同时存在且出现冲突时，将以动态规则为准。</p><h3 id="任务1：对Provider应用动态规则打标"><a href="#任务1：对Provider应用动态规则打标" class="headerlink" title="任务1：对Provider应用动态规则打标"></a>任务1：对Provider应用动态规则打标</h3><p>在Dubbo-Admin点击服务治理&#x2F;标签路由，点击创建，规则如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># governance-tagrouter-provider应用增加了两个标签分组tag1和tag2</span><br><span class="hljs-comment"># tag1包含一个实例 127.0.0.1:20880</span><br><span class="hljs-comment"># tag2包含一个实例 127.0.0.1:20881</span><br><span class="hljs-meta">---</span><br>  <span class="hljs-attr">force:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">runtime:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">key:</span> <span class="hljs-string">governance-tagrouter-provider</span><br>  <span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tag1</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;127.0.0.1:20880&quot;</span>]<br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tag2</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;127.0.0.1:20881&quot;</span>]<br> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>运行BasicConsumer，DemoService的sayHello方法只能消费所有端口为20880的服务实例， DemoService2的sayHello方法只能消费所有端口为20881的服务实例，说明路由规则生效，运行结果截图：</p><p><img src="https://img.yilonghuang.com/tag-rule-result.png" alt="tag-rule-result"></p><h3 id="任务2：对Provider应用静态规则打标"><a href="#任务2：对Provider应用静态规则打标" class="headerlink" title="任务2：对Provider应用静态规则打标"></a>任务2：对Provider应用静态规则打标</h3><p>在dubbo-demo-provider.xml中修改如下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;dubbo:service <span class="hljs-attribute">tag</span>=<span class="hljs-string">&quot;tag1&quot;</span> <span class="hljs-attribute">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.samples.governance.api.DemoService&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;demoService&quot;</span>/&gt;<br>&lt;dubbo:service <span class="hljs-attribute">tag</span>=<span class="hljs-string">&quot;tag2&quot;</span> <span class="hljs-attribute">interface</span>=<span class="hljs-string">&quot;org.apache.dubbo.samples.governance.api.DemoService2&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;demoService2&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>运行BasicConsumer，DemoService的sayHello方法只能消费所有端口为20880的服务实例， DemoService2的sayHello方法只能消费所有端口为20881的服务实例，说明路由规则生效，运行结果截图：</p><p><img src="https://img.yilonghuang.com/tag-rule-result.png" alt="tag-rule-result"></p><h3 id="规则详解-1"><a href="#规则详解-1" class="headerlink" title="规则详解"></a>规则详解</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul><li><code>Key</code>明确规则体作用到哪个应用。<strong>必填</strong>。</li><li><code>enabled=true</code> 当前路由规则是否生效，可不填，缺省生效。</li><li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 <code>false</code>。</li><li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 <code>true</code>，需要注意设置会影响调用的性能，可不填，缺省为 <code>false</code>。</li><li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 <code>0</code>。</li><li><code>tags</code> 定义具体的标签分组内容，可定义任意n（n&gt;&#x3D;1）个标签并为每个标签指定实例列表。<strong>必填</strong>。<ul><li>name， 标签名称</li></ul></li><li>addresses， 当前标签包含的实例列表</li></ul><h4 id="降级约定"><a href="#降级约定" class="headerlink" title="降级约定"></a>降级约定</h4><ol><li><p><code>dubbo.tag=tag1</code> 时优先选择 标记了<code>tag=tag1</code> 的 provider。若集群中不存在与请求标记对应的服务，默认将降级请求 tag为空的provider；如果要改变这种默认行为，即找不到匹配tag1的provider返回异常，需设置<code>dubbo.force.tag=true</code>。</p></li><li><p><code>dubbo.tag</code>未设置时，只会匹配tag为空的provider。即使集群中存在可用的服务，若 tag 不匹配也就无法调用，这与约定1不同，携带标签的请求可以降级访问到无标签的服务，但不携带标签&#x2F;携带其他种类标签的请求永远无法访问到其他标签的服务。</p></li></ol><blockquote><p><strong>提示</strong></p><p><code>2.6.x</code> 版本以及更早的版本请使用<a href="../routing-rule-deprecated">老版本路由规则</a><br>自定义路由参考<a href="../../../dev/impls/router">路由扩展</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>覆盖规则</title>
    <link href="/blog/2022/06/25/%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99/"/>
    <url>/blog/2022/06/25/%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h1><p>此任务将展示在 Dubbo 中配置应用级治理规则和服务级治理规则</p><blockquote><p><strong>提示</strong></p><p>本文描述的是新版本规则配置，而不是<a href="https://dubbo.apache.org/zh/docs/advanced/config-rule-deprecated">老版本配置规则</a></p></blockquote><p>覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。2.7.0 版本开始，支持从<strong>服务</strong>和<strong>应用</strong>两个粒度来调整动态配置。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><ul><li><p>安装idea</p></li><li><p>克隆<a href="https://github.com/Trydamere/dubbo-samples">dubbo-samples</a>到本地，idea打开</p></li><li><p>拉取dubbo-admin镜像并运行镜像</p></li></ul><blockquote><p><strong>提示</strong></p><p>可参考如下步骤部署dubbo-admin</p><ol><li>创建docker-compose.yml文件，内容如下:</li></ol><figure class="highlight nestedtext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attribute">services</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">zk</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">zk</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">2181:2181</span><br>  <span class="hljs-attribute">dubbo-admin</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">apache/dubbo-admin</span><br>    <span class="hljs-attribute">container_name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">dubbo-admin</span><br>    <span class="hljs-comment"># 等待zk启动后再启动</span><br>    <span class="hljs-attribute">depends_on</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">zk</span><br>    <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">8080:8080</span><br>    <span class="hljs-attribute">environment</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">admin.registry.address=zookeeper://zk:2181</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">admin.config-center=zookeeper://zk:2181</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">admin.metadata-report.address=zookeeper://zk:2181</span><br></code></pre></td></tr></table></figure><p>2.运行命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up</span><br></code></pre></td></tr></table></figure></blockquote><p>运行成功后，可以看见dubbo-admin界面</p><p><img src="https://img.yilonghuang.com/dubbo%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt="dubbo控制台"></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>dubbo-samples-governance示例包含dubbo-samples-applevel-override和dubbo-samples-servicelevel-override子示例，这2个子示例分别从<strong>服务</strong>和<strong>应用</strong>两个粒度应用覆盖规则动态调整路由。</p><p>此任务的最初目标是应用覆盖规则在无需重启应用的情况下动态调整流量路由。稍后，您将从<strong>服务</strong>和<strong>应用</strong>两个粒度应用规则动态调整路由。</p><p>下图展示本任务的应用端到端架构。</p><p><img src="https://img.yilonghuang.com/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="应用架构"></p><h3 id="应用粒度"><a href="#应用粒度" class="headerlink" title="应用粒度"></a>应用粒度</h3><p>dubbo-samples-applevel-override示例中，BasicConsumer类和BascicProvider类为消费者类和提供者类，现在运行BasicProvider，成功后如图：</p><p><img src="https://img.yilonghuang.com/%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8CBasicProvider.png" alt="应用运行BasicProvider"></p><p>在控制台查询服务，可以看到应用governance-appoverride-provider，如图：</p><p><img src="https://img.yilonghuang.com/dubbo%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E8%AF%A2BasicProvider.png" alt="dubbo控制台查询BasicProvider"></p><p>现在再运行一个提供者示例，运行在20881端口，首先修改dubbo-demo-provider.xml，将&lt; dubbo:protocol &#x2F;&gt;标签中端口修改修改为20881，运行BasicProvider，成功后查询控制台，如图：</p><p><img src="https://img.yilonghuang.com/dubbo%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E8%AF%A2%E4%B8%A4%E4%B8%AABasicProvider.png" alt="dubbo控制台查询两个BasicProvider"></p><blockquote><p><strong>提示</strong></p><p>如果运行BasicProvider示例失败，请修改BasicProvider配置，勾选Allow multiple instances</p></blockquote><p>目前需要临时剔除在20880端口的提供者，可以使用覆盖规则进行动态配置。</p><p>1.打开<a href="http://0.0.0.0/#/governance/config">服务治理控制台</a>，点击”创建“，填入应用名和配置，这个配置将禁用在20880端口上提供（side:provider）的所有服务（scope:application）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">governance-appoverride-provider</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;0.0.0.0:20880&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">provider</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">disabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>运行BasicConsumer，此时发现是运行在20881端口的提供者提供服务，说明覆盖规则生效。</p><p>目前需要对系统容量进行评估，进行调整权重。</p><ol><li><p>修改刚才的配置，填入配置如下，这个配置将调整20880端口的提供者权重(通常用于容量评估，缺省权重为 200)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">governance-appoverride-provider</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;0.0.0.0:20880&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">provider</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">weight:</span> <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure></li></ol><p>多次运行BasicConsumer，发现运行在20880端口的提供者示例提供服务次数多于20881端口的提供者示例。</p><p>目前需要调整负载均衡策略。</p><ol><li><p>修改刚才的配置，填入配置如下，这个配置将调整负载均衡策略：(缺省负载均衡策略为 random)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">governance-appoverride-provider</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">loadbalance:</span> <span class="hljs-string">random</span><br></code></pre></td></tr></table></figure></li></ol><p>Random策略按权重设置随机概率，多次运行BasicConsumer，BasicConsumer访问20880端口的概率大于访问20881端口的概率。</p><h3 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h3><p>dubbo-samples-servicelevel-override示例与上面的示例类似，故不赘述。运行BasicProvider类。</p><p>目前需要修改ratings服务的超时时间</p><p>1.打开<a href="http://0.0.0.0/#/governance/config">服务治理控制台</a>，点击”创建“，填入服务名和配置，这个配置将所有消费（side:consumer）DemoService服务（org.apache.dubbo.samples.governance.api.DemoService）的应用实例（addresses:[0.0.0.0]），超时时间修改为300ms</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">service</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">org.apache.dubbo.samples.governance.api.DemoService</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p>运行BasicConsumer类，发现BasicConSumer抛异常无法调用远程方法，如图：</p><p><img src="https://img.yilonghuang.com/%E6%9C%8D%E5%8A%A1%E8%B6%85%E6%97%B6%E5%BC%82%E5%B8%B8.png" alt="服务超时异常"></p><p>发现DemoService服务有bug，需要进行服务降级</p><p>1.修改刚才的配置，填入配置如下，这个配置将所有消费（side:consumer）DemoService服务的应用实例（addresses:[0.0.0.0]），无法使用DemoService服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">service</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">org.apache.dubbo.samples.governance.api.DemoService</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">force:</span> <span class="hljs-string">return</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p><em><strong>TODO: 配置不生效</strong></em></p><h2 id="规则详解"><a href="#规则详解" class="headerlink" title="规则详解"></a>规则详解</h2><h4 id="配置模板"><a href="#配置模板" class="headerlink" title="配置模板"></a>配置模板</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application/service</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">app-name/group+service+version</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br>  <span class="hljs-attr">providerAddresses:</span> [<span class="hljs-string">&quot;1.1.1.1:20880&quot;</span>, <span class="hljs-string">&quot;2.2.2.2:20881&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br>  <span class="hljs-attr">applications/services:</span> []<br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">1000</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">failfase</span><br>    <span class="hljs-attr">loadbalance:</span> <span class="hljs-string">random</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;0.0.0.0:20880&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">provider</span><br>  <span class="hljs-attr">applications/services:</span> []<br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">threadpool:</span> <span class="hljs-string">fixed</span><br>    <span class="hljs-attr">threads:</span> <span class="hljs-number">200</span><br>    <span class="hljs-attr">iothreads:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">dispatcher:</span> <span class="hljs-string">all</span><br>    <span class="hljs-attr">weight:</span> <span class="hljs-number">200</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>configVersion</code> 表示 dubbo 的版本</p></li><li><p><code>scope</code>表示配置作用范围，分别是应用（application）或服务（service）粒度。<strong>必填</strong>。</p></li><li><p><code>key</code>指定规则体作用在哪个服务或应用。<strong>必填</strong>。</p><ul><li>scope&#x3D;service时，key取值为[{group}:]{service}[:{version}]的组合</li><li>scope&#x3D;application时，key取值为application名称</li></ul></li><li><p><code>enabled=true</code> 覆盖规则是否生效，可不填，缺省生效。</p></li><li><p><code>configs</code>定义具体的覆盖规则内容，可以指定n（n&gt;&#x3D;1）个规则体。<strong>必填</strong>。</p><ul><li>side: 消费者端&#x2F;提供者端</li><li>applications: 对应用覆盖规则</li><li>services: 对服务覆盖规则</li><li>parameters: 参数列表</li><li>addresses: 地址值</li><li>providerAddresses: 提供者地址值</li></ul></li></ul><p><strong>对于绝大多数配置场景，只需要理清楚以下问题基本就知道配置该怎么写了：</strong></p><ol><li>要修改整个应用的配置还是某个服务的配置。<ul><li>应用：<code>scope: application, key: app-name</code>（还可使用<code>services</code>指定某几个服务）。</li><li>服务：<code>scope: service, key:group+service+version </code>。</li></ul></li><li>修改是作用到消费者端还是提供者端。<ul><li>消费者：<code>side: consumer</code> ，作用到消费端时（你还可以进一步使用<code>providerAddress</code>, <code>applications</code>选定特定的提供者示例或应用）。</li><li>提供者：<code>side: provider</code>。</li></ul></li><li>配置是否只对某几个特定实例生效。<ul><li>所有实例：<code>addresses: [&quot;0.0.0.0&quot;] </code>或<code>addresses: [&quot;0.0.0.0:*&quot;] </code>具体由side值决定。</li><li>指定实例：<code>addersses[实例地址列表]</code>。</li></ul></li><li>要修改的属性是哪个。</li></ol><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li><p>禁用提供者：(通常用于临时踢除某台提供者机器，相似的，禁止消费者访问请使用路由规则)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">demo-provider</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;10.20.153.10:20880&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">provider</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">disabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>调整权重：(通常用于容量评估，缺省权重为 200)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">demo-provider</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span> [<span class="hljs-string">&quot;10.20.153.10:20880&quot;</span>]<br>  <span class="hljs-attr">side:</span> <span class="hljs-string">provider</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">weight:</span> <span class="hljs-number">200</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>调整负载均衡策略：(缺省负载均衡策略为 random)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">application</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">demo-consumer</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br>  <span class="hljs-attr">parameters:</span><br>    <span class="hljs-attr">loadbalance:</span> <span class="hljs-string">random</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>服务降级：(通常用于临时屏蔽某个出错的非关键服务)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">configVersion:</span> <span class="hljs-string">v2.7</span><br><span class="hljs-attr">scope:</span> <span class="hljs-string">service</span><br><span class="hljs-attr">key:</span> <span class="hljs-string">org.apache.dubbo.samples.governance.api.DemoService</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">side:</span> <span class="hljs-string">consumer</span><br> <span class="hljs-attr">parameters:</span><br>   <span class="hljs-attr">force:</span> <span class="hljs-string">return</span> <span class="hljs-literal">null</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC笔记</title>
    <link href="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>根据<a href="https://www.bilibili.com/video/BV1TE41177mP?share_source=copy_web">黑马JUC</a>整理的笔记</p><h1 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h1><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E7%9B%AE%E5%BD%95.png" class="" title="目录"><h1 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2.进程与线程"></a>2.进程与线程</h1><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在<br>指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器<br>等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 </li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享 </li><li>进程间通信较为复杂 <ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication） </li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="2-2-并行与并发"><a href="#2-2-并行与并发" class="headerlink" title="2.2 并行与并发"></a>2.2 并行与并发</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。 一般会将这种线程轮流使用 CPU 的做法称为并发(concurrent)</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91.png" class="" title="并发"><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%B9%B6%E8%A1%8C.png" class="" title="并行"><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h4><p>以调用方的角度讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><h4 id="应用之提高效率"><a href="#应用之提高效率" class="headerlink" title="应用之提高效率"></a>应用之提高效率</h4><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的</p><ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ol><h1 id="3-Java线程"><a href="#3-Java线程" class="headerlink" title="3.Java线程"></a>3.Java线程</h1><h2 id="3-1-创建和运行线程"><a href="#3-1-创建和运行线程" class="headerlink" title="3.1 创建和运行线程"></a>3.1 创建和运行线程</h2><h3 id="方法一，直接使用-Thread"><a href="#方法一，直接使用-Thread" class="headerlink" title="方法一，直接使用 Thread"></a>方法一，直接使用 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br><span class="hljs-meta">@Override</span><br> <span class="hljs-comment">// run 方法内实现了要执行的任务</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br> log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> &#125;<br> &#125;;<br>t1.start();<br></code></pre></td></tr></table></figure><h3 id="方法二，使用-Runnable-配合-Thread"><a href="#方法二，使用-Runnable-配合-Thread" class="headerlink" title="方法二，使用 Runnable 配合 Thread"></a>方法二，使用 Runnable 配合 Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 要执行的任务</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( runnable );<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三，FutureTask-配合-Thread"><a href="#方法三，FutureTask-配合-Thread" class="headerlink" title="方法三，FutureTask 配合 Thread"></a>方法三，FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 创建任务对象</span><br>FutureTask&lt;<span class="hljs-built_in">Integer</span>&gt; task3 = <span class="hljs-literal">new</span> FutureTask&lt;&gt;(() -&gt; &#123;<br><span class="hljs-keyword">log</span>.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;);<br><br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br><br><span class="hljs-comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span><br><span class="hljs-built_in">Integer</span> result = task3.get();<br><span class="hljs-keyword">log</span>.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, result);<br></code></pre></td></tr></table></figure><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Future提供了三种功能： 　　</p><ol><li>判断任务是否完成； 　　</li><li>能够中断任务； 　　</li><li>能够获取任务执行结果。</li></ol><p><a href="https://gitee.com/link?target=https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag">FutureTask是Future和Runable的实现</a></p><h2 id="3-2-观察多个线程同时运行"><a href="#3-2-观察多个线程同时运行" class="headerlink" title="3.2 观察多个线程同时运行"></a>3.2 观察多个线程同时运行</h2><p>主要是理解</p><ul><li>交替执行</li><li>谁先谁后，不由我们控制</li></ul><h2 id="3-3-查看进程线程的方法"><a href="#3-3-查看进程线程的方法" class="headerlink" title="3.3 查看进程线程的方法"></a>3.3 查看进程线程的方法</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt; </code>查看某个进程（PID）的所有线程</li><li><code>kill</code> 杀死进程</li><li><code>top</code> 按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程</li></ul><h2 id="3-4-线程运行原理"><a href="#3-4-线程运行原理" class="headerlink" title="3.4 线程运行原理"></a>3.4 线程运行原理</h2><h3 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h3><p>每个线程启动后，虚拟机就会为其分配一块栈内存。每个方法被执行的时候都会同时创建一个<strong>栈帧(stack frame)<strong>用于存储</strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息，是属于线程的私有的。当java中使用多线程时，每个线程都会维护它自己的栈，每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li><p>线程的 cpu 时间片用完</p></li><li><p>垃圾回收</p></li><li><p>有更高优先级的线程需要运行</p></li><li><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p></li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器，它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="3-5-常见方法"><a href="#3-5-常见方法" class="headerlink" title="3.5 常见方法"></a>3.5 常见方法</h2><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95.png" class="" title="常见方法"><h2 id="3-6-start-与-run"><a href="#3-6-start-与-run" class="headerlink" title="3.6 start 与 run"></a>3.6 start 与 run</h2><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h2 id="3-7-sleep-与-yield"><a href="#3-7-sleep-与-yield" class="headerlink" title="3.7 sleep 与 yield"></a>3.7 sleep 与 yield</h2><p><strong>sleep</strong></p><ol><li><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</p></li><li><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 <code>InterruptedException</code></p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ol><p><strong>yield</strong></p><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><p><strong>线程优先级</strong></p><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h2 id="3-8-join"><a href="#3-8-join" class="headerlink" title="3.8 join"></a>3.8 join</h2><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><h2 id="3-9-interrupt"><a href="#3-9-interrupt" class="headerlink" title="3.9 interrupt"></a>3.9 interrupt</h2><p>用于打断<strong>阻塞</strong>(sleep wait join)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。线程<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false。线程抛出异常InterruptedException</li></ul><h3 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h3><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F.png" class="" title="两阶段终止模式"><p><strong>代码</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> Monitor();<br>monitor.start();<br>Thread.sleep(<span class="hljs-number">3500</span>);<br>monitor.stop();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;<br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<br>@Override<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.currentThread().interrupt();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span>()</span> &#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.interrupt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-10-sleep，yiled，wait，join-对比"><a href="#3-10-sleep，yiled，wait，join-对比" class="headerlink" title="3.10 sleep，yiled，wait，join 对比"></a>3.10 sleep，yiled，wait，join 对比</h2><ul><li>sleep，join，yield，interrupted是Thread类中的方法</li><li>wait&#x2F;notify是object中的方法</li><li>sleep 不释放锁、释放cpu</li><li>join 释放锁、join的线程抢占cpu，如t1.join(), t1抢占cpu</li><li>yield 不释放锁、释放cpu</li><li>wait 释放锁、释放cpu</li></ul><h2 id="3-11-主线程与守护线程"><a href="#3-11-主线程与守护线程" class="headerlink" title="3.11 主线程与守护线程"></a>3.11 主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><blockquote><p>注意<br>垃圾回收器线程就是一种守护线程</p></blockquote><h2 id="3-12-五种状态"><a href="#3-12-五种状态" class="headerlink" title="3.12 五种状态"></a>3.12 五种状态</h2><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.png" class="" title="五种状态"><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h2 id="3-13-六种状态"><a href="#3-13-六种状态" class="headerlink" title="3.13 六种状态"></a>3.13 六种状态</h2><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81.png" class="" title="六种状态"><ul><li><code>NEW</code> 线程刚被创建，但是还没有调用 <code>start()</code> 方法</li><li><code>RUNNABLE</code> 当调用了 <code>start()</code> 方法之后，注意，<strong>Java API</strong> 层面的 RUNNABLE 状态涵盖了 <strong>操作系统</strong> 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code>， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节详述</li><li><code>TERMINATED</code> 当线程代码运行结束</li></ul><h1 id="4-共享模型之管程"><a href="#4-共享模型之管程" class="headerlink" title="4. 共享模型之管程"></a>4. 共享模型之管程</h1><h2 id="4-1-共享带来的问题"><a href="#4-1-共享带来的问题" class="headerlink" title="4.1 共享带来的问题"></a>4.1 共享带来的问题</h2><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问<strong>共享资源</strong><ul><li>多个线程读<strong>共享资源</strong>其实也没有问题</li><li>在多个线程对<strong>共享资源</strong>读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于代码的<strong>执行序列不同</strong>而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="4-2-synchronized-解决方案"><a href="#4-2-synchronized-解决方案" class="headerlink" title="4.2 synchronized 解决方案"></a>4.2 synchronized 解决方案</h2><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p>注意</p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></blockquote><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>语法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(对象)</span></span> &#123;<br><span class="hljs-comment">//临界区</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-方法上的-synchronized"><a href="#4-3-方法上的-synchronized" class="headerlink" title="4.3 方法上的 synchronized"></a>4.3 方法上的 synchronized</h2><ul><li>加在成员方法上，锁this对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span></span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>加在静态方法上，锁Class对象</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params">Demo.<span class="hljs-keyword">class</span></span>) &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-变量的线程安全分析"><a href="#4-4-变量的线程安全分析" class="headerlink" title="4.4 变量的线程安全分析"></a>4.4 变量的线程安全分析</h2><h3 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h3><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全</p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><h3 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h3><ul><li>局部变量是线程安全的–(每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享)</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法</strong>时，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子</strong>的，所以可能会出现线程安全问题</li></ul><h4 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h4><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4-6-Monitor-概念"><a href="#4-6-Monitor-概念" class="headerlink" title="4.6 Monitor 概念"></a>4.6 Monitor 概念</h2><h3 id="原理之Monitor"><a href="#原理之Monitor" class="headerlink" title="原理之Monitor"></a>原理之Monitor</h3><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong></p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的<br>Mark Word 中就被设置指向 Monitor 对象的指针</p><p>Monitor 结构如下</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/monitor%E5%8E%9F%E7%90%86.png" class="" title="monitor原理"><ul><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li></ul><blockquote><p>注意：</p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li></ul></blockquote><h3 id="synchronized-原理进阶"><a href="#synchronized-原理进阶" class="headerlink" title="synchronized 原理进阶"></a>synchronized 原理进阶</h3><h4 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h4><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" class="" title="对象头格式"><h4 id="1-轻量级锁"><a href="#1-轻量级锁" class="headerlink" title="1. 轻量级锁"></a>1. 轻量级锁</h4><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。<br>轻量级锁对使用者是透明的，即语法仍然是 <code>synchronized</code><br>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br><span class="hljs-comment">// 同步块 A</span><br><span class="hljs-title function_">method2</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">synchronized</span>(<span class="hljs-params"> obj </span>) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%88%9B%E5%BB%BA%E9%94%81%E8%AE%B0%E5%BD%95.png" class="" title="创建锁记录"><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换Object 的 Mark Word，将 Mark Word 的值存入锁记录</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E6%9B%BF%E6%8D%A2markword.png" class="" title="替换markword"><ul><li>如果 cas 替换成功，对象头中存储了锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><ul><li>如果 cas 失败，有两种情况<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/cas%E5%A4%B1%E8%B4%A5.png" class="" title="cas失败"><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%87%8D%E5%85%A5%E8%AE%A1%E6%95%B0%E5%87%8F%E4%B8%80.png" class="" title="重入计数减一"><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头<ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h4 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="2. 锁膨胀"></a>2. 锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%A4%B1%E8%B4%A5.png" class="" title="加轻量级锁失败"><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%94%81%E8%86%A8%E8%83%80.png" class="" title="锁膨胀"><ul><li>Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li></ul><h4 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="3. 自旋优化"></a>3. 自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程<strong>自旋成功</strong>（即这时候持锁线程已经退出了同步块，<strong>释放了锁</strong>），这时当前线程就可以避免阻塞。</p><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><h4 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h4><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。<br>引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%81%8F%E5%90%91%E9%94%81.png" class="" title="偏向锁"><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" class="" title="对象头格式"><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h2 id="4-7-wait-notify"><a href="#4-7-wait-notify" class="headerlink" title="4.7 wait notify"></a>4.7 wait notify</h2><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/wait-notify.png" class="" title="wait-notify"><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片。但是有所区别：<ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><h2 id="4-8-wait-notify-的正确姿势"><a href="#4-8-wait-notify-的正确姿势" class="headerlink" title="4.8 wait notify 的正确姿势"></a>4.8 wait notify 的正确姿势</h2><h3 id="Wait与Sleep的区别"><a href="#Wait与Sleep的区别" class="headerlink" title="Wait与Sleep的区别"></a>Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="优雅地使用wait-x2F-notify"><a href="#优雅地使用wait-x2F-notify" class="headerlink" title="优雅地使用wait&#x2F;notify"></a>优雅地使用wait&#x2F;notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait&#x2F;notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法， 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，改为 notifyAll</li><li><strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），<strong>在wait端必须使用while来等待条件变量而不能使用if语句</strong></li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cos">synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span><br><span class="hljs-keyword">LOCK</span>.wait()<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-comment">//满足条件后再运行</span><br>&#125;<br><br>synchronized (<span class="hljs-keyword">LOCK</span>) &#123;<br><span class="hljs-comment">//唤醒所有等待线程</span><br><span class="hljs-keyword">LOCK</span>.notifyAll()<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式之保护性暂停"><a href="#模式之保护性暂停" class="headerlink" title="模式之保护性暂停"></a>模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><p>要点</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F.png" class="" title="两阶段终止模式"><h3 id="join源码——使用保护性暂停模式"><a href="#join源码——使用保护性暂停模式" class="headerlink" title="join源码——使用保护性暂停模式"></a>join源码——使用保护性暂停模式</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span></span><br><span class="hljs-function">    throws InterruptedException </span>&#123;<br>        <span class="hljs-type">long</span> base = System.<span class="hljs-built_in">currentTimeMillis</span>();<br>        <span class="hljs-type">long</span> now = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isAlive</span>()) &#123;<br>                <span class="hljs-type">long</span> delay = millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">wait</span>(delay);<br>                now = System.<span class="hljs-built_in">currentTimeMillis</span>() - base;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="模式之生产者消费者"><a href="#模式之生产者消费者" class="headerlink" title="模式之生产者消费者"></a>模式之生产者消费者</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test21</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        MessageQueue queue = <span class="hljs-keyword">new</span> MessageQueue(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            int id = i;<br>            <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                queue.put(<span class="hljs-keyword">new</span> Message(id , <span class="hljs-string">&quot;值&quot;</span>+id));</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;, <span class="hljs-string">&quot;生产者&quot;</span> + i)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                sleep(<span class="hljs-number">1</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                Message message = queue.take();</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;, <span class="hljs-string">&quot;消费者&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 消息队列类 ， <span class="hljs-title">java</span> 线程之间通信</span><br><span class="hljs-function">@<span class="hljs-title">Slf4j</span><span class="hljs-params">(topic = <span class="hljs-string">&quot;c.MessageQueue&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">class</span> <span class="hljs-title">MessageQueue</span> &#123;</span><br><span class="hljs-function">    // 消息的队列集合</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">Message</span>&gt; <span class="hljs-title">list</span> = <span class="hljs-title">new</span> <span class="hljs-title">LinkedList</span>&lt;&gt;<span class="hljs-params">()</span>;</span><br><span class="hljs-function">    // 队列容量</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">capcity</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">MessageQueue</span><span class="hljs-params">(int capcity)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">capcity</span> = <span class="hljs-title">capcity</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 获取消息</span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Message</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 检查队列是否为空</span><br><span class="hljs-function">        <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">list</span>)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">while</span><span class="hljs-params">(<span class="hljs-keyword">list</span>.isEmpty())</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                    <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;队列为空, 消费者线程等待&quot;</span>)</span>;</span><br><span class="hljs-function">                    <span class="hljs-title">list</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                    <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">            // 从队列头部获取消息并返回</span><br><span class="hljs-function">            <span class="hljs-title">Message</span> <span class="hljs-title">message</span> = <span class="hljs-title">list</span>.<span class="hljs-title">removeFirst</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;已消费消息 &#123;&#125;&quot;</span>, message)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">list</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">return</span> <span class="hljs-title">message</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 存入消息</span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Message message)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">list</span>)</span> &#123;</span><br><span class="hljs-function">            // 检查对象是否已满</span><br><span class="hljs-function">            <span class="hljs-title">while</span><span class="hljs-params">(<span class="hljs-keyword">list</span>.size() == capcity)</span> &#123;</span><br><span class="hljs-function">                <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">                    <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;队列已满, 生产者线程等待&quot;</span>)</span>;</span><br><span class="hljs-function">                    <span class="hljs-title">list</span>.<span class="hljs-title">wait</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">                    <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">            // 将消息加入队列尾部</span><br><span class="hljs-function">            <span class="hljs-title">list</span>.<span class="hljs-title">addLast</span><span class="hljs-params">(message)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;已生产消息 &#123;&#125;&quot;</span>, message)</span>;</span><br><span class="hljs-function">            <span class="hljs-title">list</span>.<span class="hljs-title">notifyAll</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">final</span> <span class="hljs-title">class</span> <span class="hljs-title">Message</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">int</span> <span class="hljs-title">id</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">Object</span> <span class="hljs-title">value</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(int id, <span class="hljs-built_in">Object</span> value)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">id</span> = <span class="hljs-title">id</span>;</span><br><span class="hljs-function">        <span class="hljs-title">this</span>.<span class="hljs-title">value</span> = <span class="hljs-title">value</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">id</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Object</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">value</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    @<span class="hljs-title">Override</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> &quot;<span class="hljs-title">Message</span>&#123;&quot; +</span><br><span class="hljs-function">                &quot;<span class="hljs-title">id</span>=&quot; + <span class="hljs-title">id</span> +</span><br><span class="hljs-function">                &quot;, <span class="hljs-title">value</span>=&quot; + <span class="hljs-title">value</span> +</span><br><span class="hljs-function">                &#x27;&#125;&#x27;;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-9-Park-amp-Unpark"><a href="#4-9-Park-amp-Unpark" class="headerlink" title="4.9 Park &amp; Unpark"></a>4.9 Park &amp; Unpark</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>是LockSupport类中的的方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>暂停线程运行<br>LockSupport.park;<br><br><span class="hljs-regexp">//</span>恢复线程运行<br>LockSupport.unpark(thread);<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>与wait&#x2F;notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li><li>park &amp; unpark 可以<strong>先unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p><ul><li>先调用park再调用unpark时<ul><li>先调用park<ul><li>线程运行时，会将Park对象中的**_counter的值设为0**；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li>然后调用unpark<ul><li>调用unpark方法后，会将counter的值设置为1</li><li>去唤醒阻塞队列cond中的线程</li><li>线程继续运行并将counter的值设为0</li></ul></li></ul></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%85%88%E8%B0%83%E7%94%A8park%E5%86%8D%E8%B0%83%E7%94%A8unpark(1).png" class="" title="先调用park再调用unpark(1)"><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%85%88%E8%B0%83%E7%94%A8park%E5%86%8D%E8%B0%83%E7%94%A8unpark(2).png" class="" title="先调用park再调用unpark(2)"><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E5%85%88%E8%B0%83%E7%94%A8unpark%EF%BC%8C%E5%86%8D%E8%B0%83%E7%94%A8park.png" class="" title="先调用unpark，再调用park"><h2 id="4-10-重新理解线程状态转换"><a href="#4-10-重新理解线程状态转换" class="headerlink" title="4.10 重新理解线程状态转换"></a>4.10 重新理解线程状态转换</h2><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" class="" title="重新理解线程状态转换"><h3 id="情况1-NEW-–-gt-RUNNABLE"><a href="#情况1-NEW-–-gt-RUNNABLE" class="headerlink" title="情况1 NEW –&gt; RUNNABLE"></a>情况1 <code>NEW –&gt; RUNNABLE</code></h3><ul><li>当调用了<code>t.start()</code>方法时，由<code>NEW –&gt; RUNNABLE</code></li></ul><h3 id="情况2-RUNNABLE-lt-–-gt-WAITING"><a href="#情况2-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况2 RUNNABLE &lt;–&gt; WAITING"></a>情况2 <code>RUNNABLE &lt;–&gt; WAITING</code></h3><ul><li>t 线程用 <code>synchronized(obj)</code>获取了对象锁后<ul><li>调用 <code>obj.wait()</code> 方法时，t 线程从 <code>RUNNABLE –&gt; WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt() </code>时<ul><li>竞争锁成功，t 线程从 <code>WAITING –&gt; RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING –&gt; BLOCKED</code></li></ul></li></ul></li></ul><h3 id="情况3-RUNNABLE-lt-–-gt-WAITING"><a href="#情况3-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况3 RUNNABLE &lt;–&gt; WAITING"></a>情况3 <code>RUNNABLE &lt;–&gt; WAITING</code></h3><ul><li>当前线程调用<code>t.join()</code>方法时，当前线程从 <code>RUNNABLE –&gt; WAITING</code></li><li>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 <code>interrupt()</code> 时，当前线程从 <code>WAITING –&gt; RUNNABLE</code></li></ul><h3 id="情况4-RUNNABLE-lt-–-gt-WAITING"><a href="#情况4-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况4 RUNNABLE &lt;–&gt; WAITING"></a>情况4 <code>RUNNABLE &lt;–&gt; WAITING</code></h3><ul><li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE –&gt; WAITING</code></li><li>调用<code> LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING –&gt; RUNNABLE</code></li></ul><h3 id="情况5-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况5 RUNNABLE &lt;–&gt;TIMED_WAITING"></a>情况5 <code>RUNNABLE &lt;–&gt;TIMED_WAITING</code></h3><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE –&gt;TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul><h3 id="情况6-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况6 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况6 <code>RUNNABLE &lt;–&gt; TIMED_WAITING</code></h3><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE –&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING –&gt; RUNNABLE</code></li></ul><h3 id="情况7-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况7 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况7 <code>RUNNABLE &lt;–&gt; TIMED_WAITING</code></h3><ul><li>当前线程调用 <code>Thread.sleep(long n)</code> ，当前线程从 <code>RUNNABLE –&gt; TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING –&gt; RUNNABLE</code></li></ul><h3 id="情况8-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况8 RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况8 <code>RUNNABLE &lt;–&gt; TIMED_WAITING</code></h3><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线 程从<code>RUNNABLE –&gt; TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程的 <code>interrupt()</code>，或是等待超时，会让目标线程从 <code>TIMED_WAITING–&gt;RUNNABLE</code></li></ul><h3 id="情况9-RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况9-RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况9 RUNNABLE &lt;–&gt; BLOCKED"></a>情况9 <code>RUNNABLE &lt;–&gt; BLOCKED</code></h3><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果<strong>竞争失败</strong>，从 <code>RUNNABLE –&gt; BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争 成功，从 <code>BLOCKED –&gt; RUNNABLE</code> ，其它<strong>失败</strong>的线程仍然 <code>BLOCKED</code></li></ul><h3 id="情况10-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况10-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况10 RUNNABLE &lt;–&gt; TERMINATED"></a>情况10 <code>RUNNABLE &lt;–&gt; TERMINATED</code></h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 <code>TERMINATED</code></p><h2 id="4-11-多把锁"><a href="#4-11-多把锁" class="headerlink" title="4.11 多把锁"></a>4.11 多把锁</h2><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;<br>    <span class="hljs-comment">//额外创建对象来作为锁</span><br>private <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> studyRoom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>private <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object</span> bedRoom = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-活跃性"><a href="#4-12-活跃性" class="headerlink" title="4.12 活跃性"></a>4.12 活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁 <code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>final <span class="hljs-built_in">Object</span> A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>final <span class="hljs-built_in">Object</span> B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (A) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">Thread.sleep(<span class="hljs-number">2000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (B) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (B) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">Thread.sleep(<span class="hljs-number">1000</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">synchronized (A) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul><li>互斥条件<ul><li>在一段时间内，一种资源只能被一个进程所使用</li></ul></li><li>请求和保持条件<ul><li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li></ul></li><li>不可抢占条件<ul><li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li></ul></li><li>循环等待条件<ul><li>发生死锁时，必然存在一个进程——资源的循环链。</li></ul></li></ul><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象。</p><h2 id="4-13-ReentrantLock"><a href="#4-13-ReentrantLock" class="headerlink" title="4.13 ReentrantLock"></a>4.13 ReentrantLock</h2><p>相对于 synchronized 它具备如下特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><p>基本语法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//获取ReentrantLock对象</span><br><span class="hljs-keyword">private</span> ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//加锁</span><br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//需要执行的代码</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//释放锁</span><br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁<br>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-regexp">//加锁，可打断锁</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">lock.lockInterruptibly();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125; catch (InterruptedException e) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">log.debug(&quot;等锁过程被打断&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">return;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;finally &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">//</span>释放锁</span></span><br><span class="hljs-params"><span class="hljs-function">lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;获得锁&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span>;</span><br><span class="hljs-function">//打断</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">log</span>.<span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-string">&quot;执行打断&quot;</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-regexp">//未设置等待时间，一旦获取失败，直接返回false</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">if(!lock.tryLock()) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;获取失败&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                //</span>获取失败，不再向下执行，返回</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>设置等待时间</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">try</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-regexp">//判断获取锁是否成功，最多等待1秒</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">if(!lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;获取失败&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">//</span>获取失败，不再向下执行，直接返回</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">return</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-regexp">//被打断，不再向下执行，直接返回</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">return;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">&#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">System.out.println(&quot;得到了锁&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">//</span>释放锁</span></span><br><span class="hljs-params"><span class="hljs-function">lock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">lock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">try</span>&#123;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">//打断等待</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">3000</span>)</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125; <span class="hljs-title">finally</span> &#123;</span><br><span class="hljs-function"><span class="hljs-title">lock</span>.<span class="hljs-title">unlock</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 tryLock 解决哲学家就餐问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.n4.deadlock.v2;<br><br><span class="hljs-keyword">import</span> cn.itcast.n2.util.Sleeper;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//　尝试获得左手筷子</span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 尝试获得右手筷子</span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            eat();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    left.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span><br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待<br>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws InterruptedException</span> &#123;<br>ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-comment">//获得条件变量</span><br>Condition condition = <span class="hljs-keyword">lock</span>.newCondition();<br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">while</span>(!judge) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;不满足条件，等待...&quot;</span>);<br><span class="hljs-comment">//等待</span><br>condition.<span class="hljs-keyword">await</span>();<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行完毕！&quot;</span>);<br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br><span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1</span>);<br>judge = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//释放</span><br>condition.signal();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">lock</span>.unlock();<br>&#125;<br><br>&#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>               setExclusiveOwnerThread(Thread.currentThread());<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() == Thread.currentThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>            compareAndSetState(state, state + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>         <span class="hljs-keyword">if</span> (getState() &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (getExclusiveOwnerThread() != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> getState();<br>         <span class="hljs-keyword">if</span> (state == <span class="hljs-number">1</span>) &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            compareAndSetState(state, <span class="hljs-number">0</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            compareAndSetState(state, state - <span class="hljs-number">1</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> getState() &gt;= <span class="hljs-number">1</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>      &#125;<br><br>   &#125;<br><br>   <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>      sync.acquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, time);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>      sync.release(<span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> sync.newCondition();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>      <span class="hljs-type">MyLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLock</span>();<br><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">syncLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num++;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>               lock.lock();<br>               <span class="hljs-keyword">try</span> &#123;<br>                  lock.lock();<br>                  <span class="hljs-keyword">try</span> &#123;<br>                     num--;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     lock.unlock();<br>                  &#125;<br>               &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  lock.unlock();<br>               &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>               lock.unlock();<br>            &#125;<br>         &#125;<br>      &#125;);<br><br>      t1.start();<br>      t2.start();<br>      t1.join();<br>      t2.join();<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-14-ThreadLocal"><a href="#4-14-ThreadLocal" class="headerlink" title="4.14 ThreadLocal"></a>4.14 ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalStudy</span> &#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>      <span class="hljs-comment">// 创建ThreadLocal变量</span><br>      ThreadLocal&lt;String&gt; stringThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>      ThreadLocal&lt;User&gt; userThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>      <span class="hljs-comment">// 创建两个线程，分别使用上面的两个ThreadLocal变量</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread1 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread1 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Nyima&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.<span class="hljs-keyword">out</span>.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br>         System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>          <br>          <span class="hljs-comment">// 移除</span><br> userThreadLocal.<span class="hljs-keyword">remove</span>();<br> System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      Thread thread2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>         <span class="hljs-comment">// stringThreadLocal第一次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread2 stringThreadLocal first&quot;</span>);<br>         <span class="hljs-comment">// stringThreadLocal第二次赋值</span><br>         stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;thread2 stringThreadLocal second&quot;</span>);<br>         <span class="hljs-comment">// userThreadLocal赋值</span><br>         userThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Hulu&quot;</span>, <span class="hljs-number">20</span>));<br><br>         <span class="hljs-comment">// 取值</span><br>         System.<span class="hljs-keyword">out</span>.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br>         System.<span class="hljs-keyword">out</span>.println(userThreadLocal.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      <span class="hljs-comment">// 启动线程</span><br>      thread1.start();<br>      thread2.start();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> &#123;<br>   String name;<br>   <span class="hljs-built_in">int</span> age;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(<span class="hljs-params">String name, <span class="hljs-built_in">int</span> age</span>)</span> &#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>   &#125;<br><br>   @Override<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">thread1 stringThreadLocal second<br>thread2 stringThreadLocal second<br>User&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Nyima&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br>User&#123;<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;Hulu&#x27;</span>, <span class="hljs-attribute">age</span>=20&#125;<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>从运行结果可以看出</p><ul><li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul><li>从线程1和线程2的打印结果可以看出</li></ul></li><li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul><li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li></ul></li><li>ThreadLocal可以进行以下几个操作<ul><li>set 设置值</li><li>get 取出值</li><li>remove 移除值</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Thread</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Runnable</span> &#123;<br> ...<br><br> ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-literal">null</span>;<br><br> <span class="hljs-comment">// 放在后面说</span><br> ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="hljs-literal">null</span>;<br><br> ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>    static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>        <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>        <span class="hljs-type">Object</span> value;<br><br>        <span class="hljs-type">Entry</span>(<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>            <span class="hljs-keyword">super</span>(k);<br>            value = v;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p><p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p><h2 id="4-15-InheritableThreadLocal"><a href="#4-15-InheritableThreadLocal" class="headerlink" title="4.15 InheritableThreadLocal"></a>4.15 InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span><br></code></pre></td></tr></table></figure><p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p><p>也就是从main所在的线程，传给thread1或thread2</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>      ThreadLocal&lt;<span class="hljs-keyword">String</span>&gt; stringThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocal</span>&lt;&gt;();<br>      InheritableThreadLocal&lt;<span class="hljs-keyword">String</span>&gt; stringInheritable = <span class="hljs-keyword">new</span> <span class="hljs-type">InheritableThreadLocal</span>&lt;&gt;();<br><br>      <span class="hljs-comment">// 主线程赋对上面两个变量进行赋值</span><br>      stringThreadLocal.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;this is threadLocal&quot;</span>);<br>      stringInheritable.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;this is inheritableThreadLocal&quot;</span>);<br><br>      <span class="hljs-comment">// 创建线程</span><br>      Thread thread1 = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(()-&gt;&#123;<br>         <span class="hljs-comment">// 获得ThreadLocal中存放的值</span><br>         System.out.println(stringThreadLocal.<span class="hljs-keyword">get</span>());<br><br>         <span class="hljs-comment">// 获得InheritableThreadLocal存放的值</span><br>         System.out.println(stringInheritable.<span class="hljs-keyword">get</span>());<br>      &#125;);<br><br>      thread1.start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-literal">null</span><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> inheritableThreadLocal<br></code></pre></td></tr></table></figure><p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal&lt;T&gt;</span> </span>&#123;<br>    <span class="hljs-comment">// 传入父线程中的一个值，然后直接返回</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">T</span> childValue(<span class="hljs-type">T</span> parentValue) &#123;<br>        <span class="hljs-keyword">return</span> parentValue;<br>    &#125;<br><br>  <span class="hljs-comment">// 返回传入线程的inheritableThreadLocals</span><br>    <span class="hljs-comment">// Thread中有一个inheritableThreadLocals变量</span><br>    <span class="hljs-comment">// ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br>    <span class="hljs-type">ThreadLocalMap</span> getMap(<span class="hljs-type">Thread</span> t) &#123;<br>       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>    &#125;<br><br> <span class="hljs-comment">// 创建一个inheritableThreadLocals</span><br>    void createMap(<span class="hljs-type">Thread</span> t, <span class="hljs-type">T</span> firstValue) &#123;<br>        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadLocalMap</span>(<span class="hljs-keyword">this</span>, firstValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p><h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span>()</span> &#123;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable <span class="hljs-keyword">target</span>, String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>   ...<br>        <br><span class="hljs-comment">// 获得当前线程的，在这里是主线程</span><br>    Thread parent = currentThread();<br>   <br>    ...<br>    <br>    <span class="hljs-comment">// 如果父线程的inheritableThreadLocals存在</span><br>    <span class="hljs-comment">// 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span><br>    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 设置子线程的inheritableThreadLocals</span><br>        <span class="hljs-keyword">this</span>.inheritableThreadLocals =<br>            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>    <br>    <span class="hljs-comment">/* Stash the specified stack size in case the VM cares */</span><br>    <span class="hljs-keyword">this</span>.stackSize = stackSize;<br><br>    <span class="hljs-comment">/* Set thread ID */</span><br>    tid = nextThreadID();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-title class_">ThreadLocalMap</span> <span class="hljs-title function_">createInheritedMap</span>(<span class="hljs-params">ThreadLocalMap parentMap</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(parentMap);<br>&#125;<br></code></pre></td></tr></table></figure><p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> <span class="hljs-constructor">ThreadLocalMap(ThreadLocalMap <span class="hljs-params">parentMap</span>)</span> &#123;<br>    Entry<span class="hljs-literal">[]</span> parentTable = parentMap.table;<br>    <span class="hljs-built_in">int</span> len = parentTable.length;<br>    set<span class="hljs-constructor">Threshold(<span class="hljs-params">len</span>)</span>;<br>    table = <span class="hljs-keyword">new</span> Entry<span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>        Entry e = parentTable<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        <span class="hljs-keyword">if</span> (e != null) &#123;<br>            @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)</span><br>            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get<span class="hljs-literal">()</span>;<br>            <span class="hljs-keyword">if</span> (key != null) &#123;<br>                <span class="hljs-comment">// 这里调用了 childValue 方法</span><br>                <span class="hljs-comment">// 该方法会返回parent的值</span><br>                Object value = key.child<span class="hljs-constructor">Value(<span class="hljs-params">e</span>.<span class="hljs-params">value</span>)</span>;<br>                <br>                Entry c = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Entry(<span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span>;<br>                <span class="hljs-built_in">int</span> h = key.threadLocalHashCode &amp; (len - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (table<span class="hljs-literal">[<span class="hljs-identifier">h</span>]</span> != null)<br>                    h = next<span class="hljs-constructor">Index(<span class="hljs-params">h</span>, <span class="hljs-params">len</span>)</span>;<br>                table<span class="hljs-literal">[<span class="hljs-identifier">h</span>]</span> = c;<br>                size++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p><p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p><h1 id="5-共享模型之内存"><a href="#5-共享模型之内存" class="headerlink" title="5. 共享模型之内存"></a>5. 共享模型之内存</h1><h2 id="5-1-Java-内存模型"><a href="#5-1-Java-内存模型" class="headerlink" title="5.1 Java 内存模型"></a>5.1 Java 内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。<br>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="5-2-可见性"><a href="#5-2-可见性" class="headerlink" title="5.2 可见性"></a>5.2 可见性</h2><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> Boolean run = <span class="hljs-literal">true</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(()-&gt;&#123;<br><span class="hljs-keyword">while</span> (run) &#123;<br><span class="hljs-comment">//如果run为真，则一直执行</span><br>&#125;<br>&#125;).<span class="hljs-built_in">start</span>();<br><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;改变run的值为false&quot;</span>);<br>run = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF(1).png" class="" title="退不出的循环(1)"><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF(2).png" class="" title="退不出的循环(2)"><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E9%80%80%E4%B8%8D%E5%87%BA%E7%9A%84%E5%BE%AA%E7%8E%AF(3).png" class="" title="退不出的循环(3)"><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><h3 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h3><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li>因为使用了<strong>synchronized</strong>关键字</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">public void <span class="hljs-built_in">println</span>(String x) &#123;<br><span class="hljs-comment">//使用了synchronized关键字</span><br>        synchronized (this) &#123;<br>            <span class="hljs-built_in">print</span>(x);<br>            <span class="hljs-built_in">newLine</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-3-有序性"><a href="#5-3-有序性" class="headerlink" title="5.3 有序性"></a>5.3 有序性</h2><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static int i<span class="hljs-comment">;</span><br>static int j<span class="hljs-comment">;</span><br>// 在某个线程内执行如下赋值操作<br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">j</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> <span class="hljs-operator">=</span> ...<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li><li>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></li><li>指令重排的前提是，重排指令<strong>不能影响结果</strong></li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p></li></ul><h4 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h4><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p></li></ul><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h4 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span> &#123; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-literal">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>()</span> &#123;<br><span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>synchronized(Singleton.<span class="hljs-keyword">class</span>) &#123;<br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的</p><p>发生指令重排，线程t1还未完全将构造方法构造完毕，此时线程t2拿到的是一个未初始化的单例。</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排</p><h4 id="double-checked-locking-解决"><a href="#double-checked-locking-解决" class="headerlink" title="double-checked locking 解决"></a>double-checked locking 解决</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>()</span> &#123; &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton INSTANCE = <span class="hljs-literal">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>()</span> &#123;<br><span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>synchronized (Singleton.<span class="hljs-keyword">class</span>) &#123; <span class="hljs-comment">// t2</span><br><span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br><span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><ul><li>可见性<ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ul><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int x;<br><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">Object</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    synchronized(m) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        x = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    synchronized(m) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        System.out.println(x);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">// 10</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">volatile <span class="hljs-keyword">static</span> int x;<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">x = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(x);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><ul><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int x;<br>x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">System.out.println(x);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t2&quot;</span>)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int x;<br>Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">x = <span class="hljs-number">10</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;,<span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function"><span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(x)</span>;</span><br></code></pre></td></tr></table></figure><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(x);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    <span class="hljs-keyword">while</span> (!t2.isInterrupted()) &#123;<br>        Thread.yield();<br>    &#125;<br>    System.out.println(x);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> y;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    y = <span class="hljs-number">10</span>;<br>    x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><blockquote><p>变量都是指成员变量或静态成员变量</p></blockquote><h1 id="6-共享模型之无锁"><a href="#6-共享模型之无锁" class="headerlink" title="6. 共享模型之无锁"></a>6. 共享模型之无锁</h1><h2 id="6-2-CAS-与-volatile"><a href="#6-2-CAS-与-volatile" class="headerlink" title="6.2 CAS 与 volatile"></a>6.2 CAS 与 volatile</h2><p><code>AtomicInteger</code> 内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/cas%E6%93%8D%E4%BD%9C.png" class="" title="cas操作"><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存</strong>中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><blockquote><p><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</p></blockquote><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</li></ul><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h2><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> str.get();<br>            System.out.println(<span class="hljs-string">&quot;change&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                other();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//把str中的A改为C</span><br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;C &quot;</span> + str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>));<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change A-&gt;B &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;).start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;change B-&gt;A &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Demo3 &#123;<br><span class="hljs-comment">//指定版本号</span><br>static AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>String pre = str.get<span class="hljs-constructor">Reference()</span>;<br><span class="hljs-comment">//获得版本号</span><br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other<span class="hljs-literal">()</span>;<br>&#125; catch (InterruptedException e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>&#125; catch (InterruptedException e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change A-&gt;C stamp &quot;</span> + stamp + str.compare<span class="hljs-constructor">AndSet(<span class="hljs-params">pre</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br>&#125;<br><br>static void other<span class="hljs-literal">()</span> throws InterruptedException &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;<br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change A-&gt;B stamp &quot;</span> + stamp + str.compare<span class="hljs-constructor">AndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">500</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span>-&gt; &#123;<br><span class="hljs-built_in">int</span> stamp = str.get<span class="hljs-constructor">Stamp()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;change B-&gt;A stamp &quot;</span> + stamp +  str.compare<span class="hljs-constructor">AndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-params">stamp</span>, <span class="hljs-params">stamp</span>+1)</span>);<br>&#125;).start<span class="hljs-literal">()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AtomicStampedReference 可以给原子引用加上<strong>版本号</strong>，追踪原子引用整个的变化过程，如： <code>A -&gt; B -&gt; A -&gt;C</code> ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了AtomicMarkableReference</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> &#123;<br><span class="hljs-comment">//指定版本号</span><br><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>String pre = str.getReference();<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>other();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br><span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;C mark &quot;</span> +  str.compareAndSet(pre, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>));<br>&#125;).start();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span>() throws InterruptedException</span> &#123;<br><span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;change A-&gt;A mark &quot;</span> + str.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>));<br>&#125;).start();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul><li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为<strong>版本号</strong>，来判定是否被更改过</li><li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为<strong>标记</strong>，来判断是否被更改过</li></ul><h2 id="6-7-原子累加器"><a href="#6-7-原子累加器" class="headerlink" title="6.7 原子累加器"></a>6.7 原子累加器</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>其中 Cell 即为累加单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 防止缓存行伪共享</span><br><span class="hljs-meta">@sun</span>.misc.Contended<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>        Cell(<span class="hljs-type">long</span> x) &#123; value = x; &#125;<br>        <span class="hljs-comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cas</span><span class="hljs-params">(<span class="hljs-type">long</span> prev, <span class="hljs-type">long</span> next)</span> &#123;<br>            <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapLong(<span class="hljs-built_in">this</span>, valueOffset, prev, next);<br>        &#125;<br>        <span class="hljs-comment">// 省略不重要代码</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A4%B1%E6%95%88.png" class="" title="缓存行失效"><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加 Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A4%B1%E6%95%88.png" class="" title="解决缓存行失效"><h1 id="7-共享模型之不可变"><a href="#7-共享模型之不可变" class="headerlink" title="7. 共享模型之不可变"></a>7. 共享模型之不可变</h1><h2 id="7-1-不可变"><a href="#7-1-不可变" class="headerlink" title="7.1 不可变"></a>7.1 不可变</h2><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h2 id="7-2-不可变设计"><a href="#7-2-不可变设计" class="headerlink" title="7.2 不可变设计"></a>7.2 不可变设计</h2><h3 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br><br>    <span class="hljs-comment">//....</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h3><p>发现该类、类中所有属性都是 final 的</p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改</li><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul><h3 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h3><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p><h3 id="模式之享元"><a href="#模式之享元" class="headerlink" title="模式之享元"></a>模式之享元</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时</p><h4 id="2-设计连接池"><a href="#2-设计连接池" class="headerlink" title="2.设计连接池"></a>2.设计连接池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br><br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockConnection</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title function_">prepareCall</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nativeSQL</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAutoCommit</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getAutoCommit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isClosed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DatabaseMetaData <span class="hljs-title function_">getMetaData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setReadOnly</span><span class="hljs-params">(<span class="hljs-type">boolean</span> readOnly)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCatalog</span><span class="hljs-params">(String catalog)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCatalog</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTransactionIsolation</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTransactionIsolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SQLWarning <span class="hljs-title function_">getWarnings</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearWarnings</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">(<span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title function_">prepareCall</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTypeMap</span><span class="hljs-params">(Map&lt;String, Class&lt;?&gt;&gt; map)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHoldability</span><span class="hljs-params">(<span class="hljs-type">int</span> holdability)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHoldability</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Savepoint <span class="hljs-title function_">setSavepoint</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Savepoint <span class="hljs-title function_">setSavepoint</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(Savepoint savepoint)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseSavepoint</span><span class="hljs-params">(Savepoint savepoint)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Statement <span class="hljs-title function_">createStatement</span><span class="hljs-params">(<span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency, <span class="hljs-type">int</span> resultSetHoldability)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency, <span class="hljs-type">int</span> resultSetHoldability)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title function_">prepareCall</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span> resultSetType, <span class="hljs-type">int</span> resultSetConcurrency, <span class="hljs-type">int</span> resultSetHoldability)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span> autoGeneratedKeys)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql, <span class="hljs-type">int</span>[] columnIndexes)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title function_">prepareStatement</span><span class="hljs-params">(String sql, String[] columnNames)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Clob <span class="hljs-title function_">createClob</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Blob <span class="hljs-title function_">createBlob</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> NClob <span class="hljs-title function_">createNClob</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SQLXML <span class="hljs-title function_">createSQLXML</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClientInfo</span><span class="hljs-params">(String name, String value)</span> <span class="hljs-keyword">throws</span> SQLClientInfoException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClientInfo</span><span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> SQLClientInfoException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getClientInfo</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">getClientInfo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Array <span class="hljs-title function_">createArrayOf</span><span class="hljs-params">(String typeName, Object[] elements)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Struct <span class="hljs-title function_">createStruct</span><span class="hljs-params">(String typeName, Object[] attributes)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSchema</span><span class="hljs-params">(String schema)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSchema</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(Executor executor)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNetworkTimeout</span><span class="hljs-params">(Executor executor, <span class="hljs-type">int</span> milliseconds)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNetworkTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">unwrap</span><span class="hljs-params">(Class&lt;T&gt; iface)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWrapperFor</span><span class="hljs-params">(Class&lt;?&gt; iface)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-共享模型之工具"><a href="#8-共享模型之工具" class="headerlink" title="8. 共享模型之工具"></a>8. 共享模型之工具</h1><h2 id="8-1-线程池"><a href="#8-1-线程池" class="headerlink" title="8.1 线程池"></a>8.1 线程池</h2><h3 id="1-自定义线程池"><a href="#1-自定义线程池" class="headerlink" title="1. 自定义线程池"></a>1. 自定义线程池</h3><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" class="" title="自定义线程池"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, (queue, task)-&gt;&#123;<br>            <span class="hljs-comment">//1. 死等</span><br>            queue.put(task);<br>            <span class="hljs-comment">//2. 带超时等待</span><br><span class="hljs-comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span><br>            <span class="hljs-comment">//3. 让调用者放弃任务执行</span><br><span class="hljs-comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span><br>            <span class="hljs-comment">//4. 让调用者抛出异常</span><br><span class="hljs-comment">//            throw new RuntimeException(&quot;执行任务失败 &quot;+ task);</span><br>            <span class="hljs-comment">//5. 让调用者自己执行任务</span><br><span class="hljs-comment">//            task.run();</span><br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//拒绝策略</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br><br><span class="hljs-comment">//线程池</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">//线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">//线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//获取任务时的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-comment">//执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">//当任务数没有超过coreSize时，直接交给worker对象执行</span><br>        <span class="hljs-comment">//当任务数超过coreSize时，加入任务队列暂存</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span> (workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//1. 死等</span><br>                <span class="hljs-comment">//2. 带超时等待</span><br>                <span class="hljs-comment">//3. 调用者放弃执行任务</span><br>                <span class="hljs-comment">//4. 调用者抛出异常</span><br>                <span class="hljs-comment">//5. 让调用者自己执行任务</span><br>                <br>                <span class="hljs-comment">//使用策略模式，用户传入策略避免策略写死</span><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">int</span> queueSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueSize);<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-comment">//自定义线程</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//执行任务</span><br>            <span class="hljs-comment">//1. 当task不为空，执行task</span><br>            <span class="hljs-comment">//2. 当task为空，从任务队列中获取任务并执行</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();     <br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//任务队列</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">//任务数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-comment">//任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">//生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">//消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = consumer.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            producer.signal();<br>            <span class="hljs-keyword">return</span> task;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    consumer.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            producer.signal();<br>            <span class="hljs-keyword">return</span> task;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);<br>                    producer.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            consumer.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带超时时间阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列&#123;&#125;...&quot;</span>, task);<br>                    nanos = producer.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            consumer.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//带拒绝策略的添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;加入任务队列&#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                consumer.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul><li>也可以说是平衡生产者和消费者执行速度上的差异</li><li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li></ul></li><li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul><li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li></ul></li><li>线程池中执行任务的主要方法为execute方法<ul><li>执行时要判断正在执行的线程数是否大于了线程池容量</li></ul></li></ul><h3 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2. ThreadPoolExecutor"></a>2. ThreadPoolExecutor</h3><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/ThreadPoolExecutor%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="ThreadPoolExecutor继承关系"><h2 id="8-2-J-U-C"><a href="#8-2-J-U-C" class="headerlink" title="8.2 J.U.C"></a>8.2 J.U.C</h2><h3 id="8-2-1-AQS-原理"><a href="#8-2-1-AQS-原理" class="headerlink" title="8.2.1 AQS 原理"></a>8.2.1 AQS 原理</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><h3 id="8-2-2-ReentrantLock-原理"><a href="#8-2-2-ReentrantLock-原理" class="headerlink" title="8.2.2 ReentrantLock 原理"></a>8.2.2 ReentrantLock 原理</h3><img src="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/ReentrantLock%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="ReentrantLock继承关系"><p>可以看到ReentrantLock提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p><h3 id="8-2-3-读写锁"><a href="#8-2-3-读写锁" class="headerlink" title="8.2.3 读写锁"></a>8.2.3 读写锁</h3><h4 id="1-ReentrantReadWriteLock"><a href="#1-ReentrantReadWriteLock" class="headerlink" title="1. ReentrantReadWriteLock"></a>1. ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候使用读写锁让读-读可以并发，提高性能。读-写，写-写都是相互互斥的！</p><p>注意事项</p><ol><li>读锁不支持条件变量</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li></ol><h3 id="8-2-4-Semaphore"><a href="#8-2-4-Semaphore" class="headerlink" title="8.2.4 Semaphore"></a>8.2.4 Semaphore</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><p>信号量，用来限制能同时访问共享资源的线程上限。</p><h3 id="8-2-5-CountdownLatch"><a href="#8-2-5-CountdownLatch" class="headerlink" title="8.2.5 CountdownLatch"></a>8.2.5 CountdownLatch</h3><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state &#x3D;&#x3D; 0，直至最后一个线程调用了countDown，使得state &#x3D;&#x3D; 0，于是阻塞的线程便判断成功，全部往下执行。</p><p>用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零。</p><h3 id="8-2-6-CyclicBarrier"><a href="#8-2-6-CyclicBarrier" class="headerlink" title="8.2.6 CyclicBarrier"></a>8.2.6 CyclicBarrier</h3><p>yclicBarrier循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行。跟CountdownLatch一样，但这个可以重用</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM笔记</title>
    <link href="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1yE411Z7AP">黑马JVM</a>课程所做的笔记</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><h3 id="1-1-什么是JVM"><a href="#1-1-什么是JVM" class="headerlink" title="1.1.什么是JVM?"></a>1.1.什么是JVM?</h3><p>定义</p><p>Java Virtual Machine- Java程序运行环境(Java)</p><p>好处:</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><p>比较:</p><p>jvm jre jdk</p><h2 id="2-内存结构"><a href="#2-内存结构" class="headerlink" title="2.内存结构"></a>2.内存结构</h2><ol><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li></ol><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" class="" title="内存结构"><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1.程序计数器"></a>2.1.程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>记住下一条jvm指令的执行地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有</li><li>不会存在内存溢出</li></ul><h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2.虚拟机栈"></a>2.2.虚拟机栈</h3><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧(Frame)组成，对应每个方法调用所占用的内存，栈帧中包括了局部变量,操作数栈,动态链接,方法返回地址</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><p>问题辨析</p><ol><li>垃圾回收是否涉及栈内存?<ul><li>不需要。虚拟机栈由一个个栈帧组成，在方法执行完毕后，对应栈帧会弹出栈。所以无需通过垃圾回收机制回收内存。</li></ul></li><li>栈内存分配越大越好？<ul><li>不是，物理内存是一定，栈内存越大，可以支持更多的方法调用，但是可执行线程数越少。</li></ul></li><li>方法内的局部变量是否线程安全?<ul><li>如果方法内局部变量没有逃离方法的作用范围，则是线程安全。</li><li>如果局部变量引用对象，并逃离方法的作用范围，则需要考虑线程安全</li></ul></li></ol><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3.本地方法栈"></a>2.3.本地方法栈</h3><p>一些带有native关键字的方法需要Java去调用本地的C或者C++方法，因为Java有时候没法直接和操作系统交互，所以需要本地方法。</p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4.堆"></a>2.4.堆</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字，创建对象都会使用堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>线程共享，堆中对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5.方法区"></a>2.5.方法区</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1.定义"></a>2.5.1.定义</h4><p> It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization.</p><h4 id="2-5-2-组成"><a href="#2-5-2-组成" class="headerlink" title="2.5.2.组成"></a>2.5.2.组成</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%84%E6%88%90.png" class="" title="方法区组成"><h4 id="2-5-3-运行时常量池"><a href="#2-5-3-运行时常量池" class="headerlink" title="2.5.3.运行时常量池"></a>2.5.3.运行时常量池</h4><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的表名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是*.class文件中，当该类被加载，它的常量池信息放入运行时常量池，并把里面的符号地址变成真实地址</li><li>1.8后运行时常量池还在方法区，方法区的实现为元空间，字符串常量池在堆</li></ul><h4 id="2-5-4-StringTable特性"><a href="#2-5-4-StringTable特性" class="headerlink" title="2.5.4.StringTable特性"></a>2.5.4.StringTable特性</h4><ul><li>常量池中的字符串仅是符号，第一次用到时才变成对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象加入串池。JDK1.8将字符串对象尝试放入串池，如果有则不会放入，如果没有则将对象引用放入串池，而不会重新创建对象，因为StringTable在堆中</li></ul><h3 id="2-6-直接内存"><a href="#2-6-直接内存" class="headerlink" title="2.6.直接内存"></a>2.6.直接内存</h3><h4 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1.定义"></a>2.6.1.定义</h4><p>Direct Memory</p><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-6-2-分配和回收原理"><a href="#2-6-2-分配和回收原理" class="headerlink" title="2.6.2.分配和回收原理"></a>2.6.2.分配和回收原理</h4><ul><li>使用Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用Cleaner(虚引用)来监控ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，就会由ReferenceHandler线程通过cleaner的clean方法调用freeMemory来释放直接内存</li></ul><h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3.垃圾回收"></a>3.垃圾回收</h2><h3 id="3-1-如何判断对象可以回收"><a href="#3-1-如何判断对象可以回收" class="headerlink" title="3.1.如何判断对象可以回收"></a>3.1.如何判断对象可以回收</h3><h4 id="3-1-1-引用计数法"><a href="#3-1-1-引用计数法" class="headerlink" title="3.1.1 引用计数法"></a>3.1.1 引用计数法</h4><p>弊端: 循环引用时，两个对象的计数都为1，导致两个对象都无法释放</p><h4 id="3-1-2-可达性分析算法"><a href="#3-1-2-可达性分析算法" class="headerlink" title="3.1.2 可达性分析算法"></a>3.1.2 可达性分析算法</h4><ul><li>Java虚拟机中垃圾回收器采用可达性分析来探索所有存活对象</li><li>扫描堆中对象，看是否能够沿着<code>GC ROOT对象</code>为起点的引用链找到该对象，找不到，表示可以回收</li><li>哪些对象可以作为<code>GC ROOT</code>？<ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象</li></ul></li></ul><h4 id="3-1-3-五种引用"><a href="#3-1-3-五种引用" class="headerlink" title="3.1.3 五种引用"></a>3.1.3 五种引用</h4><ol><li>强引用<ul><li>只有所有GC ROOT对象都不通过【强引用】引用该对象，该对象才能垃圾回收</li></ul></li><li>软引用<ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul></li><li>弱引用<ul><li>仅有软引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列释放弱引用自身</li></ul></li><li>虚引用<ul><li>必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存</li></ul></li><li>终结器引用<ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队(被引用对象暂时没有被回收)，再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象</li></ul></li></ol><p>引用队列</p><ul><li>软引用和弱引用可以配合引用队列<ul><li>在软引用和弱引用所引用的对象被回收后，将这些引用放入引用队列中，方便一起回收这些软&#x2F;弱引用对象</li></ul></li><li>虚引用和终结器引用必须配合引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2 垃圾回收算法"></a>3.2 垃圾回收算法</h3><h4 id="3-2-1-标记清除"><a href="#3-2-1-标记清除" class="headerlink" title="3.2.1 标记清除"></a>3.2.1 标记清除</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" class="" title="标记清除"><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应内容，给堆内存腾出相应空间</p><ul><li>这里腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，直接覆盖这段内存</li></ul><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul><li>速度较快</li><li>会造成内存碎片</li></ul><h4 id="3-2-2-标记整理"><a href="#3-2-2-标记整理" class="headerlink" title="3.2.2 标记整理"></a>3.2.2 标记整理</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" class="" title="标记整理"><ul><li>速度慢</li><li>没有内存碎片</li></ul><h4 id="3-2-3-复制"><a href="#3-2-3-复制" class="headerlink" title="3.2.3 复制"></a>3.2.3 复制</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%A4%8D%E5%88%B6.png" class="" title="复制"><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>将内存分为等大小的两个区域FROM和TO，先将被GC ROOT引用的对象从FROM放入TO，再回收不被GC ROOT引用的对象。然后交换FROM和TO。</p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><ul><li>不会有内存碎片</li><li>占用双倍内存</li></ul><h3 id="3-3分代垃圾回收"><a href="#3-3分代垃圾回收" class="headerlink" title="3.3分代垃圾回收"></a>3.3分代垃圾回收</h3><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" class="" title="分代垃圾回收"><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发minor gc，伊甸园和From存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to</li><li>minor gc会引发stop the world，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值，会晋升老年代，最大寿命是15(4 bit)</li><li>当老年代空间不足，会首先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，扫描新生代和老年代中所有不再使用的对象并回收，STW的时间更长</li></ul><h3 id="3-4垃圾回收器"><a href="#3-4垃圾回收器" class="headerlink" title="3.4垃圾回收器"></a>3.4垃圾回收器</h3><ol><li>串行<ul><li>单线程</li><li>堆内存较小</li></ul></li><li>吞吐量优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，垃圾回收时间占比最低</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单次STW时间最短</li></ul></li></ol><h4 id="3-4-1-串行"><a href="#3-4-1-串行" class="headerlink" title="3.4.1 串行"></a>3.4.1 串行</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E4%B8%B2%E8%A1%8C.png" class="" title="串行"><h4 id="3-4-2-Serial收集器"><a href="#3-4-2-Serial收集器" class="headerlink" title="3.4.2 Serial收集器"></a>3.4.2 Serial收集器</h4><p>特点：单线程、采用<strong>复制算法</strong>。对于限定单CPU的环境，Serial收集器由于没有线程交互的开销，收集效率高。收集器进行垃圾回收时，必须暂停其他所有工作线程，直到它结束(STW)</p><h4 id="3-4-3-ParNew收集器"><a href="#3-4-3-ParNew收集器" class="headerlink" title="3.4.3 ParNew收集器"></a>3.4.3 ParNew收集器</h4><p>特点：Serial收集器多线程版本，多线程，和Serial收集器一样存在STW问题。</p><h4 id="3-4-4-serial-Old收集器"><a href="#3-4-4-serial-Old收集器" class="headerlink" title="3.4.4 serial Old收集器"></a>3.4.4 serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本</p><p>特点：同样单线程收集器，采用<strong>标记-整理算法</strong>(老年代没有幸存区)</p><h4 id="3-4-5-吞吐量优先"><a href="#3-4-5-吞吐量优先" class="headerlink" title="3.4.5 吞吐量优先"></a>3.4.5 吞吐量优先</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88.png" class="" title="吞吐量优先"><h4 id="3-4-6-Parallel-Scavenge收集器"><a href="#3-4-6-Parallel-Scavenge收集器" class="headerlink" title="3.4.6 Parallel Scavenge收集器"></a>3.4.6 Parallel Scavenge收集器</h4><p>与吞吐量关系密切，也称为吞吐量优先收集器</p><p>特点: 属于新生代收集器，采用复制算法，并行多线程收集器</p><h4 id="3-4-7-Parallel-Old收集器"><a href="#3-4-7-Parallel-Old收集器" class="headerlink" title="3.4.7 Parallel Old收集器"></a>3.4.7 Parallel Old收集器</h4><p>Parallel Scavenge收集器老年代版本</p><p>特点：多线程，采用<strong>标记-整理算法</strong></p><h4 id="3-4-8-响应时间优先"><a href="#3-4-8-响应时间优先" class="headerlink" title="3.4.8 响应时间优先"></a>3.4.8 响应时间优先</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" class="" title="响应时间优先"><h4 id="3-4-9-CMS收集器"><a href="#3-4-9-CMS收集器" class="headerlink" title="3.4.9 CMS收集器"></a>3.4.9 CMS收集器</h4><p>Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</p><p>特点：基于<strong>标记-清除算法</strong>。并发收集、低停顿，但是会产生碎片</p><p>运行过程分为下列4步：</p><ol><li><strong>初始标记</strong>：标记GC ROOT能直接到的对象。速度快但是<strong>存在STW问题</strong></li><li><strong>并发标记</strong>：进行GC ROOT Tracing过程，找出存活对象并且用户线程可并发执行</li><li><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那部分对象的标记记录。<strong>存在STW问题</strong></li><li><strong>并发清除</strong>：对标记对象进行清除回收，内存回收过程是与用户线程<strong>并发执行</strong></li></ol><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/CMS%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="CMS运行示意图"><h4 id="3-4-10-G1收集器"><a href="#3-4-10-G1收集器" class="headerlink" title="3.4.10 G1收集器"></a>3.4.10 G1收集器</h4><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/G1%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="" title="G1运行示意图"><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><ol><li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li></ol><p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的</p><p>适用场景：</p><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)</li><li>超大堆内存，会将堆划分多个大小相等的Region</li><li>整体是<strong>标记+整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5.png" class="" title="G1垃圾回收阶段"><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园 S：幸存区 O：老年代</p><ul><li>会STW</li></ul><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><ul><li>在 Young GC 时会进行 GC Root 的初始标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</li></ul><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记（Remark）会 STW</li><li>拷贝存活（Evacuation）会 STW</li></ul><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><ul><li>SerialGC<ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li>ParallelGC<ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li>CMS<ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足 - full gc</li></ul></li><li>G1<ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足</li></ul></li></ul><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><p>新生代回收的跨代引用（老年代引用新生代）问题</p><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8(1).png" class="" title="跨代引用(1)"><ul><li>卡表与 <code>Remembered Set</code><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域，如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li>在引用变更时通过 <code>post-write barrier</code> + <code>dirty card queue</code></li><li><code>concurrent refinement threads</code> 更新 <code>Remembered Set</code></li></ul><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8(2).png" class="" title="跨代引用(2)"><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的 </p><p>灰色：正在处理中的 </p><p>白色：还未处理的</p><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/Remark.png" class="" title="Remark"><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><h2 id="4-类加载与字节码技术"><a href="#4-类加载与字节码技术" class="headerlink" title="4.类加载与字节码技术"></a>4.类加载与字节码技术</h2><h3 id="4-2-字节码指令"><a href="#4-2-字节码指令" class="headerlink" title="4.2 字节码指令"></a>4.2 字节码指令</h3><h4 id="4-2-3-图解方法执行流程"><a href="#4-2-3-图解方法执行流程" class="headerlink" title="4.2.3 图解方法执行流程"></a>4.2.3 图解方法执行流程</h4><h5 id="1-原始Java代码"><a href="#1-原始Java代码" class="headerlink" title="1.原始Java代码"></a>1.原始Java代码</h5><h5 id="2-编译成字节码文件"><a href="#2-编译成字节码文件" class="headerlink" title="2.编译成字节码文件"></a>2.编译成字节码文件</h5><h5 id="3-常量池载入运行时常量池"><a href="#3-常量池载入运行时常量池" class="headerlink" title="3.常量池载入运行时常量池"></a>3.常量池载入运行时常量池</h5><p>常量池也属于方法区，只不过这里单独提出来了</p><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%BD%BD%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" class="" title="常量池载入运行时常量池"><h5 id="4-方法字节码载入方法区"><a href="#4-方法字节码载入方法区" class="headerlink" title="4.方法字节码载入方法区"></a>4.方法字节码载入方法区</h5><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E6%96%B9%E6%B3%95%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%BD%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA.png" class="" title="方法字节码载入方法区"><h5 id="main线程开始运行，分配栈帧内存"><a href="#main线程开始运行，分配栈帧内存" class="headerlink" title="main线程开始运行，分配栈帧内存"></a>main线程开始运行，分配栈帧内存</h5><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/main%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C.png" class="" title="main线程开始运行"><h5 id="执行引擎开始执行字节码"><a href="#执行引擎开始执行字节码" class="headerlink" title="执行引擎开始执行字节码"></a>执行引擎开始执行字节码</h5><h4 id="4-2-10多态原理"><a href="#4-2-10多态原理" class="headerlink" title="4.2.10多态原理"></a>4.2.10多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h3 id="4-4-类加载阶段"><a href="#4-4-类加载阶段" class="headerlink" title="4.4 类加载阶段"></a>4.4 类加载阶段</h3><h4 id="4-4-1-加载"><a href="#4-4-1-加载" class="headerlink" title="4.4.1 加载"></a>4.4.1 加载</h4><blockquote><p>《深入理解Java虚拟机》</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></blockquote><ul><li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li><li>加载和链接可能是<strong>交替运行</strong>的</li></ul><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/%E5%8A%A0%E8%BD%BD.png" class="" title="加载"><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="4-4-2-链接"><a href="#4-4-2-链接" class="headerlink" title="4.4.2 链接"></a>4.4.2 链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote><p>《深入理解Java虚拟机》</p><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p></blockquote><p>为 static 变量分配空间，设置默认值</p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶</li><li>段完成</li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中的符号引用解析为直接引用</p><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p><p>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚<br>拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p><h4 id="4-4-3-初始化"><a href="#4-4-3-初始化" class="headerlink" title="4.4.3 初始化"></a>4.4.3 初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p><ul><li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p><img src="/blog/2022/04/27/JVM%E7%AC%94%E8%AE%B0/clinit%E6%B3%A8%E6%84%8F.png" class="" title="clinit注意"><h5 id="发生的时机"><a href="#发生的时机" class="headerlink" title="发生的时机"></a>发生的时机</h5><p>概括得说，类初始化是【懒惰的】</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li><p>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</p></li><li><p>类对象.class 不会触发初始化</p></li><li><p>创建该类的数组不会触发初始化</p></li><li><p>类加载器的 loadClass 方法</p></li><li><p>Class.forName 的参数 2 为 false 时</p></li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="4-5-类加载器"><a href="#4-5-类加载器" class="headerlink" title="4.5 类加载器"></a>4.5 类加载器</h3><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="4-5-1-启动类加载器"><a href="#4-5-1-启动类加载器" class="headerlink" title="4.5.1 启动类加载器"></a>4.5.1 启动类加载器</h4><h4 id="4-5-2-扩展类加载器"><a href="#4-5-2-扩展类加载器" class="headerlink" title="4.5.2 扩展类加载器"></a>4.5.2 扩展类加载器</h4><h4 id="4-5-3-双亲委派模式"><a href="#4-5-3-双亲委派模式" class="headerlink" title="4.5.3 双亲委派模式"></a>4.5.3 双亲委派模式</h4><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p><h4 id="4-5-4-线程上下文类加载器"><a href="#4-5-4-线程上下文类加载器" class="headerlink" title="4.5.4 线程上下文类加载器"></a>4.5.4 线程上下文类加载器</h4><p>JDBC使用ServiceLoader机制加载Driver驱动，即Service Provider Interface （SPI）</p><p>ServiceLoader.load 方法由Class.forName 调用了线程上下文类加载器完成类加载，线程上下文类加载器是当前线程使用的类加载器，默认就是应用程序类加载器</p><h3 id="4-6-运行期优化"><a href="#4-6-运行期优化" class="headerlink" title="4.6 运行期优化"></a>4.6 运行期优化</h3><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li>即时编译器<ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h2 id="5-内存模型"><a href="#5-内存模型" class="headerlink" title="5.内存模型"></a>5.内存模型</h2><p>内存模型内容参考 <a href="/blog/2022/05/01/JUC%E7%AC%94%E8%AE%B0/#4-共享模型之管程">4. 共享模型之管程</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具使用</title>
    <link href="/blog/2022/04/27/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2022/04/27/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="vi-和vim编辑器"><a href="#vi-和vim编辑器" class="headerlink" title="vi 和vim编辑器"></a>vi 和vim编辑器</h2><h3 id="各种模式切换"><a href="#各种模式切换" class="headerlink" title="各种模式切换"></a>各种模式切换</h3><img src="/blog/2022/04/27/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2.png" class="" title="模式切换"><h3 id="vi-和-vim-快捷键"><a href="#vi-和-vim-快捷键" class="headerlink" title="vi 和 vim 快捷键"></a>vi 和 vim 快捷键</h3><ol><li>拷贝当前行 <code>yy</code>，拷贝当前行向下5行 <code>5yy</code>, 并粘贴(输入p)</li><li>删除当前行 <code>dd</code>, 删除当前行向下5行 <code>5dd</code></li><li>在文件查找某个单词 [命令行下 &#x2F;关键字，回车查找，输入n查找下一个]</li><li>设置文件的行号，取消文件的行号 [命令行下 :set nu和 :set nonu]</li><li>在一般模式下，使用快捷键到文件的最末行[G]和最首行[gg]</li><li>在一般模式下，撤销动作<code>u</code></li><li>在一般模式下，输入<code>:行号</code>，再输入回车跳转指定行</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
